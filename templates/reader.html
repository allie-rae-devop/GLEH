<!DOCTYPE html>
<html lang="en" data-bs-theme="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="icon" href="{{ url_for('static', filename='favicon.ico') }}" type="image/x-icon">
    <title>{{ ebook.title }} - Reader</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #2b2b2b;
        }
        #reader-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        #epub-viewer {
            width: 100%;
            height: calc(100vh - 60px);
            margin-top: 60px;
        }
        #pdf-viewer {
            width: 100%;
            height: calc(100vh - 60px);
            overflow: auto;
            margin-top: 60px;
            background: #2b2b2b;
        }
        #reader-controls {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: #1a1a1a;
            padding: 10px 20px;
            z-index: 1000;
            border-bottom: 1px solid #333;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .control-group {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        #progress-bar { width: 200px; }
        canvas { max-width: 100%; }
    </style>
</head>
<body>
    <div id="reader-container">
        <!-- Reader Controls -->
        <div id="reader-controls">
            <div class="control-group">
                <a href="{{ url_for('index') }}" class="btn btn-sm btn-secondary">Back</a>
                <span class="text-white">{{ ebook.title }}</span>
            </div>

            <div class="control-group">
                <button id="prev-btn" class="btn btn-sm btn-primary">Previous</button>
                <span id="page-indicator" class="text-white small">Loading...</span>
                <button id="next-btn" class="btn btn-sm btn-primary">Next</button>
            </div>

            <div class="control-group">
                <button id="zoom-out-btn" class="btn btn-sm btn-outline-light">-</button>
                <span class="text-white small">Zoom</span>
                <button id="zoom-in-btn" class="btn btn-sm btn-outline-light">+</button>

                <div class="progress" style="width: 150px; height: 8px;">
                    <div id="progress-indicator" class="progress-bar" role="progressbar" style="width: 0%"></div>
                </div>
            </div>
        </div>

        <!-- EPUB Viewer -->
        <div id="epub-viewer" style="display: none;"></div>

        <!-- PDF Viewer -->
        <div id="pdf-viewer" style="display: none;">
            <div id="pdf-container" class="d-flex justify-content-center p-3"></div>
        </div>
    </div>

    <!-- Include libraries -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/epubjs@0.3.93/dist/epub.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>

    <script>
        const EBOOK_UID = '{{ ebook.uid }}';
        const EBOOK_PATH = '/api/ebook/{{ ebook.uid }}/';
        const EBOOK_TYPE = '{{ ebook.path }}'.toLowerCase().endsWith('.pdf') ? 'pdf' : 'epub';

        let book;
        let rendition;
        let pdfDoc;
        let currentPage = 1;
        let totalPages = 0;
        let scale = 1.5;
        let CSRF_TOKEN = null;

        // CSRF Token helper
        async function getCsrfToken() {
            if (CSRF_TOKEN) return CSRF_TOKEN;
            try {
                const response = await fetch('/csrf-token');
                const data = await response.json();
                CSRF_TOKEN = data.csrf_token;
                return CSRF_TOKEN;
            } catch (error) {
                console.error('Failed to get CSRF token:', error);
                return null;
            }
        }

        document.addEventListener('DOMContentLoaded', async () => {
            // Load saved progress
            const progress = await loadProgress();

            if (EBOOK_TYPE === 'epub') {
                initEpubReader(progress);
            } else {
                initPdfReader(progress);
            }

            setupControls();
            setupAutoSave();
        });

        async function loadProgress() {
            try {
                const response = await fetch(`/api/reading-progress/${EBOOK_UID}`);
                if (response.ok) {
                    return await response.json();
                }
            } catch (error) {
                console.error('Failed to load progress:', error);
            }
            return { current_location: null, progress_percent: 0 };
        }

        async function saveProgress(location, percent) {
            try {
                const token = await getCsrfToken();
                await fetch(`/api/reading-progress/${EBOOK_UID}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': token
                    },
                    body: JSON.stringify({
                        current_location: location,
                        progress_percent: percent
                    })
                });
                updateProgressBar(percent);
            } catch (error) {
                console.error('Failed to save progress:', error);
            }
        }

        function updateProgressBar(percent) {
            document.getElementById('progress-indicator').style.width = `${percent}%`;
        }

        async function initEpubReader(progress) {
            document.getElementById('epub-viewer').style.display = 'block';

            book = ePub(EBOOK_PATH);
            rendition = book.renderTo('epub-viewer', {
                width: '100%',
                height: '100%'
            });

            // Generate locations once for the entire book
            await book.ready;
            await book.locations.generate(1024);

            // Display book
            if (progress.current_location) {
                rendition.display(progress.current_location);
            } else {
                rendition.display();
            }

            updateProgressBar(progress.progress_percent);

            // Update progress on page turn
            rendition.on('relocated', (location) => {
                if (location && location.start) {
                    const percent = Math.round(location.start.percentage * 100);
                    const cfi = location.start.cfi;
                    saveProgress(cfi, percent);

                    // Update page indicator using pre-generated locations
                    const current = book.locations.locationFromCfi(cfi);
                    const total = book.locations.total;
                    document.getElementById('page-indicator').textContent = `${current} / ${total}`;
                }
            });
        }

        async function initPdfReader(progress) {
            document.getElementById('pdf-viewer').style.display = 'block';

            pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

            const loadingTask = pdfjsLib.getDocument(EBOOK_PATH);
            pdfDoc = await loadingTask.promise;
            totalPages = pdfDoc.numPages;

            // Resume from saved page
            if (progress.current_location) {
                currentPage = parseInt(progress.current_location) || 1;
            }

            updateProgressBar(progress.progress_percent);
            renderPage(currentPage);
        }

        async function renderPage(pageNum) {
            const page = await pdfDoc.getPage(pageNum);
            const viewport = page.getViewport({ scale });

            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.height = viewport.height;
            canvas.width = viewport.width;

            await page.render({ canvasContext: context, viewport }).promise;

            const container = document.getElementById('pdf-container');
            container.innerHTML = '';
            container.appendChild(canvas);

            // Update indicator
            document.getElementById('page-indicator').textContent = `Page ${pageNum} / ${totalPages}`;

            // Save progress
            const percent = Math.round((pageNum / totalPages) * 100);
            saveProgress(pageNum.toString(), percent);
        }

        function setupControls() {
            // Previous/Next buttons
            document.getElementById('prev-btn').addEventListener('click', () => {
                if (EBOOK_TYPE === 'epub' && rendition) {
                    rendition.prev();
                } else if (EBOOK_TYPE === 'pdf' && currentPage > 1) {
                    currentPage--;
                    renderPage(currentPage);
                }
            });

            document.getElementById('next-btn').addEventListener('click', () => {
                if (EBOOK_TYPE === 'epub' && rendition) {
                    rendition.next();
                } else if (EBOOK_TYPE === 'pdf' && currentPage < totalPages) {
                    currentPage++;
                    renderPage(currentPage);
                }
            });

            // Zoom controls (PDF only)
            document.getElementById('zoom-in-btn').addEventListener('click', () => {
                if (EBOOK_TYPE === 'pdf') {
                    scale += 0.25;
                    renderPage(currentPage);
                }
            });

            document.getElementById('zoom-out-btn').addEventListener('click', () => {
                if (EBOOK_TYPE === 'pdf' && scale > 0.5) {
                    scale -= 0.25;
                    renderPage(currentPage);
                }
            });

            // Keyboard navigation
            document.addEventListener('keydown', (e) => {
                if (e.key === 'ArrowLeft') document.getElementById('prev-btn').click();
                if (e.key === 'ArrowRight') document.getElementById('next-btn').click();
            });
        }

        function setupAutoSave() {
            // Auto-save every 30 seconds
            setInterval(() => {
                if (EBOOK_TYPE === 'epub' && rendition) {
                    const location = rendition.currentLocation();
                    if (location && location.start) {
                        const percent = Math.round(location.start.percentage * 100);
                        saveProgress(location.start.cfi, percent);
                    }
                }
                // PDF saves on page change, no need for auto-save
            }, 30000);
        }
    </script>
</body>
</html>
